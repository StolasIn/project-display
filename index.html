<html>
  <head>
    <meta charset="utf-8">
    <title>StolasIn personal page</title>
  </head>
  <body>
    <ol>
    <li>表格內換行 : alt + enter</li>
    <li>常用-跨欄至中 : 同資料在表格內統一顯示</li>
    <li>常用-設定格式化的條件 : 對於選擇的資料建立醒目的篩選</li>
    <li>檢視-凍結窗格 : 對於選擇上方的欄或列進行凍結，在離開可是範圍的時候可以持續可見</li>
    <li>資料-資料驗證 : 可以設定選擇範圍內的資料只能使用設定的參數</li>
    <li>countif()函數-第一個參數是range，第二個參數是篩選目標，結果是統計後符合條件的總數</li>
    <li>常用-自動加總 == sum()，加總選擇range中的所有數值</li>
    <li>儲存格格式可以改變數值的格式，用來以不同形態表示變數內容</li>
    <li>資料-篩選 : 可以只顯示出選擇的標籤結果</li>
    <li>常用-填滿 : 可以選擇要填滿的格數跟數值，等差數列或等比數列的</li>
    </ol>
    <h1>C++內建STL :</h1>
    <ol>
      <li><a href="#stack">stack</a></li>
      <li><a href="#queue">queue</a></li>
      <li><a href="#linked_list">linked_list</a></li>
      <li><a href="#tree">tree</a></li><br><br>
    </ol>
    <ul>
      <li><a id="stack">stack : <br><img src="https://cdn.softwaretestinghelp.com/wp-content/qa/uploads/2019/06/pictorial-representation-of-stack.png"><br></a>
      <br>形式：first in first out (FIFO)<br>
      簡介：可用linked_list實作，通常函數呼叫的時候會使用stack<br>
      s.push(變數) ：在頂端插入元素，複雜度 O(1)<br>
      s.pop() ：刪除頂端元素，複雜度 O(1)<br>
      s.top() ：回傳頂端元素，複雜度 O(1)<br>
      s.size() ：回傳stack元素個數，複雜度 O(1)<br>
      s.empty() ：回傳是否為空，空的回傳true，複雜度 O(1)<br><br><br>
      </li>
      <li><a id="queue">queue : <br><img src="https://iq.opengenus.org/content/images/2019/05/pq.png"><br></a>
      <br>形式：last in first out (LIFO) <br>
      簡介：可用linked_list實作<br>
      q.push(變數) ：插入尾端元素，複雜度 O(1)<br>
      q.pop() ：刪除頂端元素，複雜度 O(1)<br>
      q.front() ：回傳頂端元素，複雜度 O(1)<br>
      q.size() ：回傳元素個數，複雜度 O(1)<br>
      q.empty() ：回傳是否為空，複雜度 O(1)<br><br><br>
      </li>


      <li><a id="linked_list">linked_list : <br><img src="https://notepad.yehyeh.net/Content/DS/CH04/img/LinkedList.jpg"><br></a>
      <br>L.size() ：回傳元素個數，複雜度 O(1)<br>
      L.empty() ：回傳是否為空，複雜度 O(1)<br>
      L.push_front(T a),L.push_back(T a) ：插入頂端/尾端元素，複雜度 O(1)<br>
      L.pop_front(),L.pop_back() ：刪除頂端/尾端元素，複雜度 O(1)<br>
      L.insert(iterator it,size_type n,T a) ：在 it 指的那項的前面插入 n 個 a 並回傳指向 a 的迭代器。複雜度 O(n)<br>
      L.erase(iterator first,iterator last) ：把 \[first,last) 指到的東西全部刪掉，回傳 last。複雜度與砍掉的數量呈線性關係，如果沒有指定 last, 那會自動視為只刪除 first 那項<br>
      L.splice(iterator it,list &x,iterator first,iterator last) ：first 和 last 是 x 的迭代器。此函式會把 [first,last) 指到的東西從 x 中剪下並加到 it 所指的那項的前面。x 會因為這項函式而改變。若未指定 last, 那只會將 first 所指的東西移到 it 前方。複雜度與轉移個數呈線性關係<br><br><br>
      
      <li><a id="tree">tree : <br><img src="https://2.bp.blogspot.com/-wKnnD4xzV0U/Wb4o4owb_GI/AAAAAAABVjc/7qgHpEZIuAcfPWSORxZHZw23PchUbkxSwCLcBGAs/s1600/trees-6.PNG"><br></a>
      <br><b>set : <br><img src="https://www.tenouk.com/Module28_files/listsetmultiset019.png"><br></b><br>
      <br>s.size() ：回傳元素個數，複雜度 O(1)<br>
      s.empty() ：回傳是否為空，複雜度 O(1)<br>
      s.clear() ：清除元素，複雜度 O(size)<br>
      s.insert(a) ：加入元素 a, 複雜度 O(log(size))<br>
      s.erase(iterator first,iterator last) ：刪除 [first,last) , 若沒有指定 last 則只刪除 first, 複雜度 O(logsize) 與加上元素個數有關係<br>
      s.erase(a) ：刪除鍵值 a, 複雜度 O(log(size))<br>
      s.find(a) ：回傳指向鍵值 a 的迭代器，若不存在則回傳 s.end (), 複雜度 O(log(size))<br>
      s.lower_bound(a) ：回傳指向第一個鍵值大於等於 a 的迭代器。複雜度 O(log(size))<br>
      s.upper_bound(a) ：回傳指向第一個鍵值大於 a 的迭代器。複雜度 O(log(size))<br><br><br>
      <b>map :</b>
      m.size(),m.empty(),m.clear(),m.erase(iterator first,iterator last),m.erase(T1 a),m.find(T1 a),m.lower_bound(T1 a),m.upper_bound(T1 a) ：同 set<br>
      m[a] ：存取鍵值 a 對應的值，若 a 沒有對應的值，會插入一個元素，使 a 對應到預設值並回傳之。複雜度 O(logsize)<br>
      m.insert(pair<T1,T2> a) ：若沒有鍵值為 a.first 的值，插入一個鍵值為 a.first 的值對應到 a.second, 並回傳一個 pair,first 是指向剛插入的元素的迭代器、second 是 true; 若已經有了，回傳一個 pair,first 是指向鍵值為 k.first 的元素的迭代器，second 是 false。複雜度 O(logsize)<br><br>
      </li>
    </ul>
    <h1></h1>
    <a href="https://fjuonlinejudge.github.io/Training/">reference
   </body>
</html>
